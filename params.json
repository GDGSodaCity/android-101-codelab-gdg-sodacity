{"name":"Android 101","tagline":"A codelab for getting started with Android ","body":"# Welcome\r\n\r\nThis codelab is designed to help you get started with Android development and become familiar with the basics. During this lab we will create a scrollable gridview of images loaded from the network. \r\n\r\n# Things we'll use\r\n\r\nHere are the tools and utilities we will use in this lab:\r\n\r\n-\t[Android Studio](http://developer.android.com/sdk/index.html) - The IDE for developing Android applications\r\n-\t[Material Design Icon Generator](https://github.com/konifar/android-material-design-icon-generator-plugin) - IDE plugin for generating Material Design Icon assets directly into the project\r\n-\t[Support Library](http://developer.android.com/tools/support-library/index.html) - A series of libraries that provides extra support outside of the Android SDK for android development including backward compatibility for Material Design and other features and utilities.\r\n\t-\t[RecyclerView](http://developer.android.com/tools/support-library/features.html#v7-recyclerview) - a view for efficiently displaying large data sets by providing a limited window of data items.\r\n\t-\t[AppCompat](http://developer.android.com/tools/support-library/features.html#v7-appcompat) - A library that includes support for material design user interface implementations.\r\n-\t[Picasso](http://square.github.io/picasso/) - A powerful image downloading and caching library for Android\r\n\r\n# Getting Started\r\n\r\nOnce you've installed Android Studio and Java you be presented with this screen:\r\n\r\n![Screen 1](https://raw.githubusercontent.com/GDGSodaCity/android-101-codelab-gdg-sodacity/master/images/screen_2.png)\r\n\r\nFrom here select `Start a new Android Studio project` and you will be presented with the screen where you will name your project and company domain (i.e.; usually your website, or github address, e.g.; `r0adkll.com` or `r0adkll.github.io`) that is used to generate your applications unique package name that is used as it's identifier when install on a device and in the Playstore.\r\n\r\n![Screen 2](https://raw.githubusercontent.com/GDGSodaCity/android-101-codelab-gdg-sodacity/master/images/screen_3.png)\r\n\r\nAfter entering your project name and domain, you will then be asked to select your minimum target Android SDK. The default is **16** (Jelly Bean 4.1) however I now start my applications at **17** (Jelly Bean 4.2) for the ease of development. \r\n\r\nAfter selecting your minimum SDK you will be projected to add a template activity to the project (or none if you want to add it yourself) and here you will see a variety of quick start options but for now we will select the **Blank Activity** template to start.\r\n\r\n![Screen 3](https://raw.githubusercontent.com/GDGSodaCity/android-101-codelab-gdg-sodacity/master/images/screen_4.png)\r\n\r\nThis template will generate an Activity class, a XML layout file for this activity and screen, and a XML layout for an option menu. You will be presented with naming these files in the following screen after continuing.\r\n\r\n![Screen 4](https://raw.githubusercontent.com/GDGSodaCity/android-101-codelab-gdg-sodacity/master/images/screen_5.png)\r\n\r\nOnce you select _Finish_ Android Studio will create and open your new project which will look a little something like this:\r\n\r\n![AndroidStudio](https://raw.githubusercontent.com/GDGSodaCity/android-101-codelab-gdg-sodacity/master/images/androidstudio_layout.png)\r\n\r\nThe window outlined in <span style=\"color: red;\">Red</span> is your **Project Structure** which is the tree view of your entire project heirarchy. Within this window you can select between multiple different types of views, for example the default is the **Android** view which presents your projects files, resources, and configuration files in a more streamlined way cutting out the other files in the project that aren't directly need for development. These views are denoted in the <span style=\"color: gold;\">Yellow</span> outline. If you wish to just view the raw file tree then select the **Project** view.\r\n\r\nThe window outlined in <span style=\"color: turquoise\">Blue</span> is your main editor window, here all your resource and source(read: java) files will appear for you to code and edit. \r\n\r\nThe window outlined in <span style=\"color: limegreen\">Green</span> is the **Toolbar** this is where all your basic actions lie such as the basics (open, save, refresh, undo, redo, cut, copy, past) and shortcuts to build/run/debug your project, pull or push to version control, and sync your gradle configuration to the project and open the Android emulator device manager, Android project manager, and extra debugging tools.\r\n\r\n# Configuring\r\n\r\nNow that we have created our project and become familiar with the basics of the IDE we can begin coding our project! \r\n\r\nFirst, let's get familiar with the basics for every Android project:\r\n\r\n#### *build.gradle* - Gradle build configuration script\r\n\r\nIf you look under root item `Gradle Scripts` in your **Project Structure** window you will see a list of gradle based files that define how our application is built, but for now we will only focus on the `build.gradle` file, the one that is followed by `(Module: app)`. This is our projects **main** build configuration, and will look like this: \r\n\r\n```\r\napply plugin: 'com.android.application'\r\n\r\nandroid {\r\n    compileSdkVersion 23\r\n    buildToolsVersion \"23.0.1\"\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.sodacity.android101\"\r\n        minSdkVersion 17\r\n        targetSdkVersion 23\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n    }\r\n    \r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n}\r\n\r\ndependencies {\r\n    compile fileTree(dir: 'libs', include: ['*.jar'])\r\n    testCompile 'junit:junit:4.12'\r\n    compile 'com.android.support:appcompat-v7:23.1.0'\r\n    compile 'com.android.support:design:23.1.0'\r\n}\r\n```\r\n\r\nI will step through and explain the individual elements of this script that are import to our application:\r\n\r\n\tapply plugin: 'com.android.application'\r\n\t\r\nHere we are applying the Android gradle plugin to the script that tells the build system how to build an Android application from the following defined configuration. (Alternatively if you are building a library project it would be `apply plugin: 'com.android.library'`)\r\n\r\n```\r\nandroid {\r\n    compileSdkVersion 23\r\n    buildToolsVersion \"23.0.1\"\r\n\r\n\t...\r\n}\r\n```\r\n\r\nHere we set which android sdk version we want to compile with and with what version of the build tools we want to use. These values are set automatically for you when you create a new project, but as you maintain your project these values will need to be updated when a new version of Android or build tools are released.\r\n\r\n```\r\nandroid {\r\n    ...\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.sodacity.android101\"\r\n        minSdkVersion 17\r\n        targetSdkVersion 23\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n    }\r\n    \r\n\t...\r\n}\r\n```\r\n\r\nHere is our default configuration block that defines the basic attributes of the application:\r\n\r\n-\t`applicationId` - This is the packagename that we talked about earlier, the unique identifier for your application\r\n-\t`minSdkVersion` - This is the minimum version of Android that you want your application to run on, this value was determined in the previous project setup process\r\n-\t`targetSdkVersion` - This is the Latest version of android you plan on targeting. If you don't set this to the latest version of android that doesn't mean that it _won't_ run on that latest, it just means you can't use any of the new features in the SDK introduced by the latest version. (i.e. if you target Lollipop you wont' get access to the Fingerprint API or the new Permission model).\r\n-\t`versionCode` - This is your application's build number. Whenever you release updates this number will have to be larger than the previous release for the user to install it and for the PlayStore to accept it.\r\n-\t`versionName` - The version name for your application, this is not required to be changed between updates.\r\n\r\n```\r\nandroid {\r\n    ...\r\n\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nHere is where our application's build types are defined. By default, the project includes `debug` and `release` where the debug build type is implicit and always defined. You can override it by adding a `debug {}` block under `buildTypes`. \r\n\r\n```\r\ndependencies {\r\n    compile fileTree(dir: 'libs', include: ['*.jar'])\r\n    testCompile 'junit:junit:4.12'\r\n    compile 'com.android.support:appcompat-v7:23.1.0'\r\n    compile 'com.android.support:design:23.1.0'\r\n}\r\n```\r\n\r\nLastly, we have our `dependencies` block where our external (or internal) dependencies are defined and subsequently loaded into our project. By default it is setup to compile and load any JAR files you put in a `libs` folder in the base of the app module. It also includes the App compatibilty and design support libraries for building the latest and greatest UIs that are backwards compatible. \r\n\r\nHere is where you would add any third party libraries that you would want to use to make your development easier such as image loading libraries (Picasso), or networking libraries (OkHttp, Retrofit, Volley, etc...) or anything else you can find. \r\n\r\nI did a presentation on this topic that goes more in depth about this part of the toolchain which you can find on [Speaker Deck](https://speakerdeck.com/r0adkll/posscon-open-source-and-dependency-management-for-android)\r\n\r\n---\r\n\r\n#### AndroidManifest.xml \r\n\r\nEvery Android application contains an AndroidManifest.xml file which is essentially your application's table of contents, or index. It goes further than the build.gradle configuration to define more in-depth and internal aspects of your application. It will look something like this when you first create your application:\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest package=\"io.github.sodacity.android101\"\r\n          xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    >\r\n\r\n\t<!--\r\n\r\n        This is where you would define the permissions your application needs, such as Internet,\r\n        Location access, access to the external file storage system, bluetooth, and so on...\r\n\r\n    -->\r\n    <!-- <uses-permission android:name\"...\" /> -->\r\n\r\n    <!--\r\n\r\n        The application definition. Here we specify the Application name('label') that the user sees,\r\n        the application 'icon' displayed in the launcher, and the base theme.\r\n\r\n    -->\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/AppTheme\"\r\n        >\r\n\r\n        <!--\r\n\r\n            Each activity you create needs to be defined here under the Application definition\r\n            where you specify the path to the activity relative to the package. You can also specify\r\n            it's default label and override the base application theme.\r\n\r\n        -->\r\n        <activity\r\n            android:name=\".MainActivity\"\r\n            android:label=\"@string/app_name\"\r\n            android:theme=\"@style/AppTheme.NoActionBar\"\r\n            >\r\n\r\n            <!--\r\n\r\n                Activities can contain Intent Filters, i.e.; a hook for androids communication layer\r\n                that can catch certain messages and display the activity in accordance. For example,\r\n                the following intent filter tells the OS that this activity is the main one and to\r\n                launch it when the user selects the application from the home screen or launcher.\r\n\r\n            -->\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\"/>\r\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\r\n            </intent-filter>\r\n        </activity>\r\n\r\n    </application>\r\n\r\n</manifest>\r\n```\r\n\r\nThis example contains documentation breaking down each aspect of this file to explain how it operates.\r\n\r\n# The Meat!\r\n\r\nTo reiterate, our objective with this lab is to build an application that displays a scrolling grid of placeholder images loaded from the internet. First we need to add some dependencies to the `build.gradle` for the support library for the `RecyclerView` which lets us build a scrollable grid that efficiently recycles views. We will also need to add an Image Loading library, Picasso, to seemlessly load images from the web.\r\n\r\n#### Setup our app\r\n\r\nSo add these lines to the `dependencies {...}` block in your `build.gradle` file:\r\n\r\n\tcompile 'com.android.support:recyclerview-v7:23.1.0'\r\n\tcompile 'com.squareup.picasso:picasso:2.5.2'\r\n\t\r\nWhich should now look something like this:\r\n\r\n\tdependencies {\r\n\t    compile fileTree(dir: 'libs', include: ['*.jar'])\r\n\t    testCompile 'junit:junit:4.12'\r\n\t    compile 'com.android.support:appcompat-v7:23.1.0'\r\n\t    compile 'com.android.support:design:23.1.0'\r\n\t    compile 'com.android.support:recyclerview-v7:23.1.0'\r\n\t\tcompile 'com.squareup.picasso:picasso:2.5.2'\r\n\t}\r\n\r\nNow that we have our dependencies defined and loaded we need to give our app permission to access the Internet. We define our applications permissions in the `AndroidManifest.xml` file. So add this line to your AndroidManifest file above the `<Application ...` tag:\r\n\r\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\r\n\t\r\nAwesome! Now we can load images from the internet!.\r\n\r\n#### What's an Activity?\r\n\r\nIn an Android app every screen you see is backed by an `Activity`. You can think of it as a ViewController, or as a _Screen_. When building your UI can have have multiple screens per `Activity` by using an element called `Fragment`s, or you can have one screen per `Activity`. For the purposes of this lab we will be using the latter as `Fragment`s are a more advanced topic. \r\n\r\n#### Setup our Activity\r\n\r\nFirst, we will need to add the `RecyclerView` to our layout to be displayed in the `Activity`. Open the `content_main.xml` file found under `res/layout`. Once there, replace the `<TextView...` hello word view with this:\r\n\r\n    <android.support.v7.widget.RecyclerView\r\n        android:id=\"@+id/recycler_view\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\"\r\n\r\n        android:padding=\"4dp\"\r\n        android:clipToPadding=\"false\"\r\n        />\r\n\t        \r\nSo now your `content_main.xml` file should look something like this:\r\n\r\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n\t<RelativeLayout\r\n\t    xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\r\n\t    android:layout_width=\"match_parent\"\r\n\t    android:layout_height=\"match_parent\"\r\n\t\r\n\t    app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"\r\n\t    tools:context=\"io.github.sodacity.android101.MainActivity\"\r\n\t    tools:showIn=\"@layout/activity_main\"\r\n\t    >\r\n\t\r\n\t    <android.support.v7.widget.RecyclerView\r\n\t        android:id=\"@+id/recycler_view\"\r\n\t        android:layout_width=\"match_parent\"\r\n\t        android:layout_height=\"match_parent\"\r\n\t\r\n\t        android:padding=\"4dp\"\r\n\t        android:clipToPadding=\"false\"\r\n\t        />\r\n\t\r\n\t</RelativeLayout>\r\n\t\r\nNext, in our `MainActivity.java` class we want to bind this RecyclerView so that we can set it's adapter and display the grid view of items. So in the activity class you'll want to define a `RecyclerView` field/variable so we can have a reference to it later, so add this line to the top of your class:\r\n\r\n\tprivate RecyclerView recyclerView;\r\n\t\r\nNext we want to bind the recycler view from the layout using the Activities `findViewById(...)` method, so add this line to the bottom of the `protected void onCreate(Bundle savedInstanceState){...}` method:\r\n\r\n    recyclerView = (RecyclerView) findViewById(R.id.recycler_view);\r\n    \r\nNow that we have bound our `RecyclerView` into our activity we need build a list of items to display and how to build an adapter for them to use in the `RecyclerView`.\r\n\r\n#### Let's build our Model and Adapter\r\n\r\nSo we need to build a model object that will represent each cell in the gridview that contains a url to an image to load from the network. I've provided such object that randomly generates an image url from 3 different *placeholder* image websites:\r\n\r\n```\r\npublic class Placeholder {\r\n\r\n    public static final String[] PLACEHOLDER_SITES = new String[]{\r\n            \"http://www.placecage.com/%d/%d\",\r\n            \"https://placekitten.com/%d/%d\",\r\n            \"http://lorempixel.com/%d/%d\"\r\n    };\r\n\r\n    public static String generateRandomPlaceholder(){\r\n        Random r = new Random(System.nanoTime());\r\n        String base = PLACEHOLDER_SITES[r.nextInt(PLACEHOLDER_SITES.length)];\r\n        int width = r.nextInt(100) + 300;\r\n        int height = r.nextInt(100) + 300;\r\n        return String.format(base, width, height);\r\n    }\r\n\r\n    private final String url;\r\n\r\n    public Placeholder(){\r\n        url = generateRandomPlaceholder();\r\n    }\r\n\r\n    public String getUrl() {\r\n        return url;\r\n    }\r\n\r\n}\r\n```\r\n\r\nEvery time you create a new instance of this object, i.e.; `new Placeholder()` it will generate a random image url from the 3 different sources and varing width and height to ensure the services don't send us too many duplicates.\r\n\r\nNow that we have our model object we need to build the adapter that tells our `RecyclerView` how to build and display a list of these objects. For that we need to create a class that extends `RecyclerView.Adapter<VH>` which is responsible for creating `RecyclerView.ViewHolder` objects which are wrapper objects for our item layout xml file and view bindings that the `RecyclerView` can efficiently create, re-use, and destroy. \r\n\r\nBefore we build our adapter we need to create our layout that will be used to display each of our objects in the adapter. We'll want to use just an `ImageView` widget to display our image from the web, so our layout, called `item_layout_placeholder.xml` in the `res/layout` folder will look something like this:\r\n\r\n```\r\n<ImageView\r\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:id=\"@+id/image\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"96dp\"\r\n    android:scaleType=\"centerCrop\"\r\n    android:layout_margin=\"4dp\"\r\n\r\n    android:foreground=\"?attr/selectableItemBackground\"\r\n    />\r\n```\r\n\r\nOur view here will display each cell at a height of 96 density independant pixels, which really isn't optimal as we want to display image image as a square for better consistancy and UX. So we need to subclass the `ImageView` to force it's height to be the same as the width. Add this class `SquareImageView.java` to your package:\r\n\r\n```\r\npublic class SquareImageView extends ImageView {\r\n    public SquareImageView(Context context) {\r\n        super(context);\r\n    }\r\n    public SquareImageView(Context context, AttributeSet attrs) {\r\n        super(context, attrs);\r\n    }\r\n    public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {\r\n        super(context, attrs, defStyleAttr);\r\n    }\r\n\r\n    @Override\r\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\r\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\r\n\r\n        int size = getMeasuredWidth();\r\n        setMeasuredDimension(size, size);\r\n    }\r\n}\r\n```\r\n\r\nNow we need to update the layout XML file to use this custom widget, so it will now look like this:\r\n\r\n```\r\n<io.github.sodacity.android101.SquareImageView\r\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:id=\"@+id/image\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"wrap_content\"\r\n    android:scaleType=\"centerCrop\"\r\n    android:layout_margin=\"4dp\"\r\n\r\n    android:foreground=\"?attr/selectableItemBackground\"\r\n    />\r\n```\r\n\r\nNow that we have our layout we need a ViewHolder that binds the `SquareImageView` from the layout into code. The resulting class will look like this: \r\n\r\n```\r\nstatic class PlaceholderViewHolder extends RecyclerView.ViewHolder{\r\n    SquareImageView image;\r\n    public PlaceholderViewHolder(View itemView) {\r\n        super(itemView);\r\n        image = (SquareImageView) itemView;\r\n    }\r\n}\r\n```\r\n\r\nNow we can create our Adapter subclass, `PlaceholderRecyclerAdapter.java`, which once created should look like this:\r\n\r\n```\r\npublic class PlaceholderRecyclerAdapter extends RecyclerView.Adapter<PlaceholderRecyclerAdapter.PlaceholderViewHolder> {\r\n\r\n    @Override\r\n    public PlaceholderViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\r\n\t\treturn null;\r\n    }\r\n\r\n    @Override\r\n    public void onBindViewHolder(PlaceholderViewHolder holder, final int position) {\r\n        \r\n    }\r\n\r\n    @Override\r\n    public int getItemCount() {\r\n        return 0;\r\n    }\r\n\r\n    static class PlaceholderViewHolder extends RecyclerView.ViewHolder{\r\n        SquareImageView image;\r\n        public PlaceholderViewHolder(View itemView) {\r\n            super(itemView);\r\n            image = (SquareImageView) itemView;\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\nWe'll need to give this class a reference to the `Activity` to use it's layout inflater, and we'll also need to maintain a `List<>` of `Placeholder` objects that it will use to display it's content. So add these two variables to the top of the class:\r\n\r\n\tprivate Activity activity;\r\n\tprivate List<Placeholder> items;\r\n\t\r\nThen add this constructor that gives the adapter the reference to the `Activity` when it is instanitiated and initializes our array for the model objects:\r\n\r\n\tpublic PlaceholderRecyclerAdapter(Activity activity){\r\n\t\tthis.activity = activity;\r\n\t\tthis.items = new ArrayList<>();\r\n\t}\r\n\t\r\nNow we need tell the adapter's `getItemCount()` method how many items are in the data structure at any given time:\r\n\r\n    @Override\r\n    public int getItemCount() {\r\n        return items.size();\r\n    }\r\n    \r\nNext we want to fill out the `onCreateViewHolder` method to tell the adapter how to construct viewholders whenever it needs them by inflating the item layout and passing it to the class we made earlier:\r\n\r\n    @Override\r\n    public PlaceholderViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\r\n        View view = activity.getLayoutInflater().inflate(R.layout.item_layout_placeholder, parent, false);\r\n        return new PlaceholderViewHolder(view);\r\n    }\r\n    \r\nNext we need to bind our modal objects to the previously constructed view holders. First we need to get the modal object at the given position `int position` by inserting this line into the method:\r\n\r\n\tPlaceholder item = items.get(position);\r\n\t\r\nNext we what to load the image at the item's `url` path into the image view. To do this we will use the **Picasso** library we imported earlier in our `build.gradle` file. Picasso provides a very streamline api for loading images directly into images, which in our case will look like this:\r\n\r\n\tPicasso.with(activity)\r\n           .load(item.getUrl())\r\n           .placeholder(new ColorDrawable(Color.GRAY))\r\n           .into(holder.image);\r\n           \r\nwhere we pass it the url of the image to load, a color to use as a placeholder until it loads, and the `ImageView` to load it into and that's it! The image will be downloaded, cached, and automatically applied to the `ImageView` we passed. Magical!!\r\n\r\nNow that we have completed the necessary methods of the adapter for it to function we need to add some methods so we can pass updated data modals, or remove them, from the adapter. Add these methods to the class:\r\n\r\n```\r\npublic void addAll(List<Placeholder> placeholders) {\r\n    items.addAll(placeholders);\r\n}\r\n\r\npublic void add(Placeholder placeholder) {\r\n    items.add(placeholder);\r\n}\r\n\r\npublic void clear() {\r\n    items.clear();\r\n}\r\n```\r\n\r\n#### Pull it all together\r\n\r\nNow that we have our data model and `RecyclerView` adapter we can now bring it all together and bind it to the `RecyclerView`. First, we need to create a local reference to the adapter by adding this line to the top of the class:\r\n\r\n\tprivate PlaceholderRecyclerAdapter adapter;\r\n\t\r\nthen we need to create a new instance of this adapter by adding this line to the bottom of the `onCreate(...)` method in the Activity class:\r\n\r\n\tadapter = new PlaceholderRecyclerAdapter(this);\r\n\t\r\nNow we can setup our `RecyclerView` with this adapter and set it up to be a gridview by the following 2 lines:\r\n\r\n\trecyclerView.setAdapter(adapter);\r\n\trecyclerView.setLayoutManager(new GridLayoutManager(this, 3));\r\n\t\r\nNow our recyclerview is bound to our adapter and setup to be a gridview with 3 columns. Feel free to play around with this number if you want to have 2 columns, or 6. \r\n\r\nNext we need to create a set of placeholder items to give the adapter and view to display, so we will create 20 objects and add it to the adapter and notify it that it's underlying data structure has changed:\r\n\r\n```\r\nList<Placeholder> placeholders = new ArrayList<>();\r\nfor (int i = 0; i < 20; i++) {\r\n    placeholders.add(new Placeholder());\r\n}\r\n\r\nadapter.addAll(placeholders);\r\nadapter.notifyDataSetChanged();\r\n```\r\n\r\nNow you should be able to run the project and see a grid of random images that load from the network.!!! WHOOOO\u0010!! [Pat self on the back]\r\n\r\n#### BONUS ROUND!!!\r\n\r\nHere are some extra things todo if time permits:\r\n\r\n*\tAdd a new placeholder model object to the adapter when the user presses the FloatingActionButton.\r\n*\tAdd an option menu to the `res/menu/main_menu.xml` file that clears out the adapter.\r\n*\tAdd a click listener to each cell that shows a snackbar when the user clicks it.\r\n* \tChange the theme colors in `res/values/styles.xml` (i.e.; colorPrimary, colorPrimaryDark, and colorAccent)\r\n* \tAdd some material design icons for the menu item and floating action button with the [Material Design Icon Generator](https://github.com/konifar/android-material-design-icon-generator-plugin)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}